# options
setopt histverify             # when using ! cmds, confirm first
setopt hist_ignore_all_dups   # ignore all double commands in history
setopt hist_ignore_space      # don't add commands to history that start with space
setopt hist_reduce_blanks     # reduce blanks in history
setopt share_history          # share history among zsh sessions
setopt no_check_jobs          # don't report on bg processes when exiting
setopt no_hup                 # and don't kill them
setopt correct                # correct only commands
setopt complete_in_word       # completion "inside" word
setopt auto_param_slash       # add trailing slash to directory names
setopt auto_remove_slash      # remove trailing slash when appropriate
setopt list_types             # show ls -F style marks in file completion
setopt no_cdable_vars         # who wants to cd apache?
setopt prompt_subst           # dynamic prompt changes
setopt combining_chars        # fixes for completion and UTF-8
setopt no_list_beep           # no beep sound when complete list displayed
setopt no_beep                # no beep on zle errors

# custom completion paths
if [ -d ~/.zsh/completion ]; then
  export FPATH="~/.zsh/completion:$FPATH"
fi

if [ -d /usr/local/share/zsh/site-functions ]; then
  export FPATH="/usr/local/share/zsh/site-functions:$FPATH"
fi

if [ -d /usr/local/share/zsh-completions ]; then
  export FPATH="/usr/local/share/zsh-completions:$FPATH"
fi

# path modifications
if [ -d $HOME/Documents/Code/Scripts ]; then
  export PATH="$HOME/Documents/Code/Scripts:$PATH"
elif [ -d $HOME/Documents/Scripts ]; then
  export PATH="$HOME/Documents/Scripts:$PATH"
fi

if [ -d $HOME/Documents/Code/Bin ]; then
  export PATH="$HOME/Documents/Code/Bin:$PATH"
fi

if [ -d /usr/local/bin ]; then
  export PATH="/usr/local/bin:$PATH"
fi

if [ -d /usr/local/sbin ]; then
  export PATH="/usr/local/sbin:$PATH"
fi

if [ -d /sbin ]; then
  export PATH="/sbin:$PATH"
fi

if [ -d /usr/sbin ]; then
  export PATH="/usr/sbin:$PATH"
fi

if [ -d /usr/local/opt/coreutils/libexec/gnubin ]; then
  export PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"
fi

if [ -d /usr/local/share/npm/bin ]; then
  export PATH="$PATH:/usr/local/share/npm/bin"
fi

# grab latest nvm node by default
if [ -d ~/.nvm/versions/node/ ]; then
  local last_node="$(ls ~/.nvm/versions/node/ | tail -1)"
  export PATH="$HOME/.nvm/versions/node/$last_node/bin:$PATH"
fi

# terminfo
if [ -d $HOME/.terminfo ]; then
  export TERMINFO=$HOME/.terminfo/
fi

# clean paths
typeset -gU fpath path cdpath manpath

# load modules
autoload -Uz colors compinit vcs_info zmv zrecompile

# completions without security check
compinit -C

# colors
colors

# zrecompile for faster zsh
[ -f ~/.zshrc ]             && zrecompile -q -p ~/.zshrc     > /dev/null 2>&1
[ -f ~/.zcompdump ]         && zrecompile -q -p ~/.zcompdump > /dev/null 2>&1
[ -f ~/.zshrc.zwc.old ]     && rm -f ~/.zshrc.zwc.old        > /dev/null 2>&1
[ -f ~/.zcompdump.zwc.old ] && rm -f ~/.zcompdump.zwc.old    > /dev/null 2>&1

# lazy sourcing
function lazy_source() {
  eval "$1 () { [ -f $2 ] && source $2 && $1 \$@ }"
}

# live command coloring
if [ -f ~/.zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]; then
  source ~/.zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

  ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern)

  ZSH_HIGHLIGHT_PATTERNS+=('rm -rf *' 'fg=black,bg=red')
  ZSH_HIGHLIGHT_PATTERNS+=('ssh *' 'fg=black,bg=blue')

  ZSH_HIGHLIGHT_STYLES[precommand]='fg=magenta'
  ZSH_HIGHLIGHT_STYLES[commandseparator]='fg=yellow'
  ZSH_HIGHLIGHT_STYLES[path]='none'
  ZSH_HIGHLIGHT_STYLES[path_prefix]='none'
  ZSH_HIGHLIGHT_STYLES[path_approx]='none'
  ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=yellow'
  ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=yellow'
  ZSH_HIGHLIGHT_STYLES[back-quoted-argument]='fg=magenta'
  ZSH_HIGHLIGHT_STYLES[single-quoted-argument]='fg=red'
  ZSH_HIGHLIGHT_STYLES[double-quoted-argument]='fg=red'
fi

# z for better jumps
if [ -f ~/.zsh/plugins/z/z.sh ]; then
  _Z_CMD="j"
  source ~/.zsh/plugins/z/z.sh
fi

# bd for better up
if [ -f ~/.zsh/plugins/zsh-bd/bd.zsh ]; then
  source ~/.zsh/plugins/zsh-bd/bd.zsh
fi

# rbenv init
if hash rbenv 2> /dev/null; then
  eval "$(rbenv init --no-rehash -)"
  (rbenv rehash &) 2> /dev/null
fi

# lazy nvm init
if [ -d /usr/local/opt/nvm/ ]; then
  export NVM_DIR=~/.nvm

  if [ ! -d $NVM_DIR ]; then
    mkdir ~/.nvm/ > /dev/null 2>&1
    cp -f /usr/local/opt/nvm/nvm-exec ~/.nvm/ > /dev/null 2>&1
  fi

  lazy_source nvm /usr/local/opt/nvm/nvm.sh
fi

# grc for more colors
if hash grc 2> /dev/null; then
  alias colourify="grc -es --colour=auto"
  alias diff="colourify diff"
  alias make="colourify make"
  alias gcc="colourify gcc"
  alias g++="colourify g++"
  alias ld="colourify ld"
  alias netstat="colourify netstat"
  alias ping="colourify ping"
  alias traceroute="colourify traceroute"
fi

# vcs info
zstyle ":vcs_info:*" enable git #svn
zstyle ":vcs_info:*" check-for-changes true
zstyle ":vcs_info:*" stagedstr "%{$fg[red]%}"
zstyle ":vcs_info:*" unstagedstr "%{$fg[red]%}"
zstyle ":vcs_info:*" branchformat "%r"
zstyle ":vcs_info:*" actionformats "%{$fg[green]%}%b %{$fg[yellow]%}%u%c"
zstyle ":vcs_info:*" formats "%{$fg[green]%}%b %{$fg[yellow]%}%u%c"

local VCS='$vcs_info_msg_0_'

# prompt colors
if [ "$(uname)" = "Darwin" ]; then
  PROMPTCOLOR=blue
elif [ "$(hostname)" = "Disa" ]; then
  PROMPTCOLOR=yellow
else
  PROMPTCOLOR=magenta
fi

if [ "$(whoami)" = "root" ]; then
  PROMPTCOLOR=red
fi

# main prompt
PROMPT="%{$fg[$PROMPTCOLOR]%}%50<...<%3~%{$reset_color%} $VCS> %{$reset_color%}"

# right prompt
RPROMPT="%(?,,%{$fg[red]%}✕%{$reset_color%})"

# unfinished loops prompt
PROMPT2="%{$fg[yellow]%}%_%{$reset_color%} > "

# spelling prompt
SPROMPT="correct '%R' to '%r' ? ([Y]es/[N]o/[E]dit/[A]bort) "

# zsh vim mode
bindkey -v
export KEYTIMEOUT=1

# colors
export GREP_COLOR=34
if [ -f ~/.dircolors ]; then
  eval $(dircolors -b ~/.dircolors)
fi

# less modifications (including man colors)
export LESSCHARSET="utf-8"
export LESS_TERMCAP_mb=$(tput setaf 2)
export LESS_TERMCAP_md=$(tput setaf 6)
export LESS_TERMCAP_me=$(tput sgr0)
export LESS_TERMCAP_so=$(tput setaf 3; tput setab 4)
export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
export LESS_TERMCAP_us=$(tput smul; tput setaf 7)
export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
export LESS_TERMCAP_mr=$(tput rev)
export LESS_TERMCAP_mh=$(tput dim)
export LESS_TERMCAP_ZN=$(tput ssubm)
export LESS_TERMCAP_ZV=$(tput rsubm)
export LESS_TERMCAP_ZO=$(tput ssupm)
export LESS_TERMCAP_ZW=$(tput rsupm)
export LESS="-R --RAW-CONTROL-CHARS"

# homebrew exports
export HOMEBREW_NO_EMOJI=1

# locale exports
export LANG="en_US.UTF-8"
export LC_COLLATE="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"

# editor export
if hash nvim 2> /dev/null; then
  export EDITOR="nvim"
else
  export EDITOR="vim"
fi

# aliases
alias e=$EDITOR
alias v=$EDITOR
alias n="nvim"
alias sudo="sudo "

alias ls="LC_COLLATE=C ls --color=auto --group-directories-first --classify --human-readable"
alias ll="LC_COLLATE=C ls --color=auto --group-directories-first --classify --human-readable -l"
alias la="LC_COLLATE=C ls --color=auto --group-directories-first --classify --human-readable -l --almost-all"

alias rm="rm -iv"
alias mv="mv -iv"
alias cp="cp -iv"

alias back="cd - > /dev/null"
alias jumps="j | cut -b12- | tail -10"
alias dirs="dirs -v"
alias mkdir="mkdir -p"

alias df="df -h"
alias du="du -sh"
alias ag="ag --smart-case"

alias grep="egrep --color=auto"
alias less="less -i --tabs=2"
alias diff="colordiff"
alias wget="wget -c"
alias watch="watch -n1 -c -t"

alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""

alias x="exit"
alias c="clear"

alias t="tree -aC -I '.git|node_modules|bower_components'"
alias td="tree -adC -I '.git|node_modules|bower_components'"

alias zmv="zmv -w"
alias zcp="zmv -Cw"

alias -g C="| wc -l"
alias -g G="| egrep -i --color=auto"
alias -g H="| head"
alias -g T="| tail"
alias -g L="| less"
alias -g M="| more -i"
alias -g S="| sort"
alias -g B="> /dev/null 2>&1 &"

alias -g N="; notify-terminal"
alias -g P="; pushover-terminal"

# tmux
function tm() {
  local attach=""
  local title=""

  if [ "$#" -ne 0 ]; then
    title=$1
  else
    if [[ $PWD != $HOME ]]; then
      local dir=""
      if [[ ${PWD##*/} == "Code" ]]; then
        local dirname="$(dirname "$PWD")"
        dir=$(basename "$dirname")
      else
        dir=${PWD##*/}
      fi

      title="$(echo $dir | tr "[:upper:]" "[:lower:]" | sed "s/\ /\-/g")"
    else
      title="home"
    fi
  fi

  tmux has-session -t $title > /dev/null 2>&1

  if [ $? -eq 0 ]; then
    attach=$title
  else
    for session in $(tmux ls 2>/dev/null | cut -d: -f1); do
      if [[ $session =~ $title  ]]; then
        attach=$session
        break
      fi
    done
  fi

  if [[ $attach != "" ]]; then
    if [ -z $TMUX ]; then
      tmux attach -t $attach
    else
      tmux switch-client -t $attach
    fi
  else
    if [ -z $TMUX ]; then
      tmux new -s $title
    else
      TMUX=$(tmux new-session -d -s $title)
      tmux switch-client -t $title
    fi
  fi
}
compctl -s "$(tmux ls 2> /dev/null | cut -d: -f1)" tm

alias tl="tmux ls | sed 's/:/;/' | sed 's/\[.*\]//g' | column -t -s ';'"

# mac only
if [ "$(uname)" = "Darwin" ]; then
  # make completion /Applications aware
  compctl -f \
    -x 'p[2]' \
    -s "$(/bin/ls -d1 /Applications/*/*.app /Applications/*.app | sed 's|^.*/\([^/]*\)\.app.*|\\1|;s/ /\\\\ /g')" \
    -- open
  alias run="open -a"

  alias localip="ipconfig getifaddr en1"

  alias qopen="qlmanage -p "$@" >& /dev/null"
  alias flush="dscacheutil -flushcache; sudo killall -HUP mDNSResponder"
  alias clearlogs="sudo rm -rfv /private/var/log/asl/*.asl"
  alias cleartmp="sudo rm -rfv /private/var/tmp/Xcode/ /private/var/tmp/Processing/"
  alias purge="sudo purge"

  alias chromekill="ps ux | grep '[C]hrome Helper --type=renderer' | grep -v extension-process | tr -s ' ' | cut -d ' ' -f2 | xargs kill"
  alias openedports="sudo lsof -i -P | grep -i 'listen'"
  alias appsonnetwork="sudo lsof -P -i -n | tail -n+2 | cut -f 1 -d ' ' | uniq | sort --ignore-case"

  # output of last command to clipboard
  alias clout="fc -e - | pbcopy"

  # current pwd to clipboard
  alias cpwd='echo -n \"$(pwd | tr -d "\n")\" | pbcopy'

  # nice markdown files in cli using markdown-pdf from npm
  if hash markdown-pdf 2> /dev/null; then
    alias markdown-pdf-nice="markdown-pdf --css-path ~/Documents/Code/Markdown/Byword.css --render-delay 50 --paper-border 2cm"
  fi

  # network utility port scan
  if [ -d /System/Library/CoreServices/Applications/Network\ Utility.app ]; then
    alias stroke="/System/Library/CoreServices/Applications/Network\ Utility.app/Contents/Resources/stroke"
  fi

  # airport utility
  alias airport="/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport"

  # taskpaper related
  if [ -d ~/Documents/Dropbox/Tasks/ ]; then
    alias tasks-next="node ~/Documents/Projects/Archive/TaskPaperNext/app.js"
  fi

  # man in preview
  function pman() {
    man -t $1 | open -f -a Preview;
  }
  compdef _man pman=man

  # cd to currently open dir in finder
  function cdf() {
    finder_dir=$(osascript -e 'try' \
      -e 'tell application "Finder" to get POSIX path of (target of front Finder window as text)' \
      -e 'end try')
    cd "$finder_dir"
  }

  # shorter open
  function o() {
    if [ "$#" -ne 0 ]; then
      ARG="${1:+"$@"}"
    else
      ARG="."
    fi

    open $ARG
  }
fi

# linux only
if [ "$(uname)" = "Linux" ]; then
  alias localip="ifconfig eth0 | grep inet | awk '{ print \$2 }'"

  alias reboot="sudo systemctl reboot"
  alias shutdown="sudo systemctl poweroff"
fi

# use local npm binaries
function npm-exec() {
  if ! hash npm 2> /dev/null; then
    nvm use default
  fi

  "$(npm bin)/$@"
}

# sudo previous command
function sudothat() {
  echo -e "$(tput setaf 1)sudo$(tput sgr0) → $(fc -ln -1)"
  eval "sudo $(fc -ln -1)"
}

# man in vim
function viman() {
  $EDITOR -c "Man $1 $2" -c "silent only"
}
compdef _man viman=man

# grep in vim
function vigrep() {
  $EDITOR -c "call GrepHandler(\"$@\")"
}

# history
function h() {
  if [ "$#" -eq 0 ]; then
    history
  else
    history 0 | egrep -i --color=auto $@
  fi
}

# go up n directories
function up() {
  for updirs in $(seq ${1:-1}); do
    cd ..
  done
}

# mkdir & cd
function cdir() {
  if [ ! -d "$@" ]; then
    mkdir -p "$@"
  fi
  cd "$@"
}

# cd & ls
function cdl() {
  cd "$@" && LC_COLLATE=C ls --color=auto --group-directories-first --classify --human-readable
}
compdef _cd cdl=cd

# make backup and back
function bak() {
  for file in "$@"; do
    if [[ $file =~ "\.bak$" ]]; then
      mv -iv "$file" "$(basename ${file} .bak)"
    else
      mv -iv "$file" "${file}.bak"
    fi
  done
}

# rename files
function name() {
  newname=$1
  vared -c -p "rename to: " newname
  command mv $1 $newname
}

# code pager with highlight
function codecat() {
  local syntax=""
  if [ -t 0 ]; then
    case $@ in
      *.m|*.mm)          syntax="--syntax=objc" ;;
      *rc|*config|*.*sh) syntax="--syntax=sh"   ;;
      *.*json)           syntax="--syntax=js"   ;;
    esac
    highlight $syntax --out-format=ansi --replace-tabs=2 "$@" | less
  else
    cat - | highlight --out-format=ansi --replace-tabs=2 "$@" | less
  fi
}
compdef _gnu_generic codecat=cat

# simple httpserver
function httpserver() {
  local port="3000"
  if [ "$#" -ne 0 ]; then
    port="$@"
  fi

  if hash http-server 2> /dev/null; then
    http-server -p $port -c-1
  else
    local command=""
    if [ "$(uname)" = "Darwin" ]; then
      command="SimpleHTTPServer"
    else
      command="http.server"
    fi

    python -m $command $port
  fi
}

# dropbox notes
if [ -d ~/Documents/Dropbox/Notes ]; then
  function ns() {
    if [ "$#" -eq 0 ]; then
      for f in ~/Documents/Dropbox/Notes/*.txt; do
        basename $f .txt
      done
    else
      if [ -n "$(find ~/Documents/Dropbox/Notes -iname "*$@*")" ]; then
        if [ -t 1 ]; then
          find ~/Documents/Dropbox/Notes -iname "*$@*" \
            -exec echo -e "$(tput setaf 5)\n$(basename {} .txt)\n$(tput sgr0)" \; \
            -exec cat {} \; \
            -exec echo \;
        else
          find ~/Documents/Dropbox/Notes -iname "*$@*" -exec cat {} \;
        fi
      else
        echo "No note matches your search"
      fi
    fi
  }

  function ne() {
    if [ "$#" -eq 0 ]; then
      echo "You must give note name"
    else
      find ~/Documents/Dropbox/Notes -iname "*$@*" -exec $EDITOR "{}" +
    fi
  }

  compctl -g "~/Documents/Dropbox/Notes/*.txt(:t)" ne
fi

# simple find functions
function fn() {
  find . -iname "*$@*" 2>/dev/null
}

function fd() {
  find . -iname "*$@*" -type d 2>/dev/null
}

function ff() {
  find . -iname "*$@*" -type f 2>/dev/null
}

# fzf functions
if hash fzf 2> /dev/null; then
  # default options
  export FZF_DEFAULT_COMMAND="ag -l -g ''"
  export FZF_DEFAULT_OPTS="--inline-info --ansi --extended --cycle
                           --history=$HOME/.fzfhistory
                           --history-size=10000
                           --color=bg+:0,hl:110,hl+:110
                           --color=prompt:110,marker:110,pointer:110,spinner:110,info:110"

  # edit files in editor
  function fe() {
    fzf --multi --select-1 --exit-0 --query="$1" --prompt="files > " --reverse | tr "\n" "\0" | xargs -0 -o vim
  }

  # cd to directory
  function fcd() {
    local dir="$(find ${1:-*} -path '*/\.*' -prune -o -type d -print 2> /dev/null | fzf --select-1 --exit-0 --query="$1" --prompt='dir > ' --reverse)"
    [ -n "$dir" ] && cd "$dir"
  }

  # search through history
  function fh() {
    print -z $(fc -l 1 | fzf --tac --no-sort --nth=2.. --reverse --query="$1" --prompt="history > " --reverse | sed 's/ *[0-9]* *//')
  }

  # run app with preselected multiple arguments
  function fr() {
    fzf --select-1 --exit-0 --multi --query="$1" --prompt="run > " --reverse | sed -e "s/^/'/g" -e "s/$/'/g" | tr '\n' ' ' | xargs $@ ;
  }

  # kill process
  function fkill() {
    ps -ef | sed 1d | fzf --multi --query="$1" --prompt="kill > " --reverse | awk '{ print $2 }' | xargs kill -${1:-9}
  }

  # jump in fzf
  unalias j
  function j() {
    if [[ -z "$*" ]]; then
      cd "$(_z -l 2>&1 | sed -n 's/^[ 0-9.,]*//p' | fzf --no-sort --tac --prompt='jump > ' --reverse)"
    else
      _z "$@"
    fi
  }

  # tmux session
  function ftsession() {
    local session=$(tmux list-sessions -F "#{session_name}" | fzf --select-1 --exit-0 --query="$1" --prompt="session > ")
    [ -n "$session" ] && tmux switch-client -t "$session"
  }

  # tmux pane
  function ftpane() {
    local panes target

    panes=$(tmux list-panes -a -F '#S;[#I:#P];#T')
    target=$(echo "$panes" | column -t -s ";" | sort | fzf --tac --no-sort --select-1 --exit-0 --query="$1" --prompt="pane > ") || return

    local target_session=$(echo $target | cut -d " " -f1)
    local target_window=$(echo $target | cut -d "[" -f2 | awk 'BEGIN{FS=":|-"} {print $1}')
    local target_pane=$(echo $target | cut -d "[" -f2 | awk 'BEGIN{FS=":|-"} {print $2}' | cut -c 1)

    if [ -z "$TMUX" ]; then
      tmux attach-session -t "$target_session" \; select-pane -t "$target_window.$target_pane"
    else
      tmux switch-client -t "$target_session:$target_window.$target_pane"
    fi
  }
fi

# archive extractor
function extract() {
  if [[ -z "$1" ]]; then
    echo "extracts files based on extensions"
  elif [[ -f $1 ]]; then
    case ${(L)1} in
      *.tar.bz2) tar -jxvf $1  ;;
      *.tar.gz)  tar -zxvf $1  ;;
      *.tar.xz)  tar -xvf $1   ;;
      *.bz2)     bunzip2 $1    ;;
      *.gz)      gunzip $1     ;;
      *.jar)     unzip $1      ;;
      *.rar)     unrar x $1    ;;
      *.tar)     tar -xvf $1   ;;
      *.tbz2)    tar -jxvf $1  ;;
      *.tgz)     tar -zxvf $1  ;;
      *.zip)     unzip $1      ;;
      *.Z)       uncompress $1 ;;
      *)         echo "unable to extract '$1'"
    esac
  else
    echo "file '$1' does not exist!"
  fi
}
compctl -g '*.tar.bz2 *.tar.gz *.bz2 *.gz *.jar *.rar *.tar *.tbz2 *.tgz *.zip *.Z' + -g '*(-/)' extract

# calculator
function calc() {
  local result=""
  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"

  if [ "$result" == *.* ]; then
    printf "$result" | sed -e 's/^\./0./' -e 's/^-\./-0./' -e 's/0*$//;s/\.$//'
  else
    printf "$result"
  fi

  printf "\n"
}

# clock
if hash tty-clock 2> /dev/null; then
  alias clock="tty-clock -cDC4"
else
  function clock() {
    while sleep 1; do
      printf "\r%s " "$(date +%T)"
    done
  }
fi

# sanitize permissions
function sanitize() {
  if [ "$#" -eq 0 ]; then
    local DIR="."
  else
    local DIR="$@"
  fi

  find "$DIR" -type d -print0 | xargs -0 chmod 755
  find "$DIR" -type f -print0 | xargs -0 chmod 644
}

# history
HISTFILE=~/.zshhistory
HISTSIZE=10000
SAVEHIST=10000

# bindkeys - find yours by: cat > /dev/null
bindkey "^[b"   backward-word
bindkey "^[f"   forward-word
bindkey "^[[2~" overwrite-mode
bindkey "^[[3~" delete-char
bindkey "^[[5~" up-line-or-search
bindkey "^[[6~" down-line-or-search
bindkey "^R"    history-incremental-search-backward
bindkey "^[[A"  history-beginning-search-backward
bindkey "^[[B"  history-beginning-search-forward

case $TERM in
  *xterm*|urxvt|(u|dt|k|E)term)
    bindkey "^[[H" beginning-of-line
    bindkey "^[[F" end-of-line
  ;;
  *screen*)
    bindkey "^[[1~" beginning-of-line
    bindkey "^[[4~" end-of-line
  ;;
esac

# terminal titles & vcs refresh
case $TERM in
  xterm*|urxvt|(u|dt|k|E)term)
    precmd () {
      vcs_info
      print -nP "\033]0;%m: %3~\007"
    }
    preexec () {
      print -nP "\033]0;%m: $1\007"
    }
  ;;
  screen*)
    precmd () {
      vcs_info
      print -nP "\ek%3~\e\\"
      print -nP "\e]0;%3~\a"
      # print -nP "\033]0;%m $WINDOW: %3~\007"
      print -nP "\033]0;%m: %3~\007"
    }
    preexec () {
      print -nP "\ek%3~ $1\e\\"
      print -nP "\e]0;%3~ $1\a"
      # print -nP "\033]0;%m $WINDOW: $1\007"
      print -nP "\033]0;%m: $1\007"
    }
  ;;
esac

# use proper cursor with iTerm
if [ "$TERM_PROGRAM" = "iTerm.app" ]; then
  function zle-keymap-select zle-line-init {
    if [[ $TMUX != "" ]]; then
      case $KEYMAP in
        vicmd)      print -n -- "\033Ptmux;\033\E]50;CursorShape=0\C-G\033\\";;
        viins|main) print -n -- "\033Ptmux;\033\E]50;CursorShape=1\C-G\033\\";;
      esac
    else
      case $KEYMAP in
        vicmd)      print -n -- "\E]50;CursorShape=0\C-G";;
        viins|main) print -n -- "\E]50;CursorShape=1\C-G";;
      esac
    fi
  }

  function zle-line-finish {
    if [[ $TMUX != "" ]]; then
      print -n -- "\033Ptmux;\033\E]50;CursorShape=0\C-G\033\\"
    else
      print -n -- "\E]50;CursorShape=0\C-G"
    fi
  }

  zle -N zle-line-init
  zle -N zle-line-finish
  zle -N zle-keymap-select
fi

# complete with dots on slow systems
expand-or-complete-with-dots() {
  echo -n "$(tput setaf 6)...$(tput sgr0)"
  zle expand-or-complete
  zle redisplay
}
zle -N expand-or-complete-with-dots
bindkey "^I" expand-or-complete-with-dots

# speed up completion by avoiding partial globs.
zstyle ':completion:*' accept-exact '*(N)'
zstyle ':completion:*' accept-exact-dirs true

# use completion cache
zstyle ":completion:*" use-cache true

# colors in completion
zstyle ":completion:*" list-colors ${(s.:.)LS_COLORS}

# separate directories from files.
zstyle ':completion:*' list-dirs-first true

# process names from ps
zstyle ":completion:*:processes" command "ps cx -o pid,user,%cpu,%mem,comm"
zstyle ":completion:*:processes-names" command "ps -aeo comm="

# kill & killall completion colors
zstyle ":completion:*:*:kill:*:processes" list-colors "=(#b) #([0-9]#)*=0=01;31"
zstyle ":completion:*:*:killall:*:processes-names" list-colors "=(#b) #([0-9]#f)*=0=01;31"

# complete with menu
setopt menucomplete
zstyle ":completion:*" menu select=long-list select=1

# list of completers to use
zstyle ":completion:*" completer _expand _complete _approximate

# remove the trailing slash (usefull in ln)
zstyle ":completion:*" squeeze-slashes true

# complete ssh/scp
zstyle ':completion:*:scp:*' tag-order 'hosts:-host hosts:-domain:domain hosts:-ipaddr:IP\ address *'
zstyle ':completion:*:scp:*' group-order users files all-files hosts-domain hosts-host hosts-ipaddr
zstyle ':completion:*:ssh:*' tag-order users 'hosts:-host hosts:-domain:domain hosts:-ipaddr:IP\ address *'
zstyle ':completion:*:ssh:*' group-order hosts-domain hosts-host users hosts-ipaddr

zstyle ':completion:*:(ssh|scp):*:hosts-host' ignored-patterns '*.*' loopback localhost
zstyle ':completion:*:(ssh|scp):*:hosts-domain' ignored-patterns '<->.<->.<->.<->' '^*.*' '*@*'
zstyle ':completion:*:(ssh|scp):*:hosts-ipaddr' ignored-patterns '^<->.<->.<->.<->' '127.0.0.<->'
zstyle ':completion:*:(ssh|scp):*:users' ignored-patterns adm bin daemon halt lp named shutdown sync

zstyle -e ':completion:*:(ssh|scp):*' hosts 'reply=(
  ${=${${(f)"$(cat {/etc/ssh_,~/.ssh/known_}hosts(|2)(N) /dev/null)"}%%[# ]*}//,/ }
  ${=${(f)"$(cat /etc/hosts(|)(N) <<(ypcat hosts 2>/dev/null))"}%%\#*}
  ${=${${${${(@M)${(f)"$(<~/.ssh/config)"}:#Host *}#Host }:#*\**}:#*\?*}}
)'

# ignore completions for commands that we dont have
zstyle ":completion:*:functions" ignored-patterns "_*"

# auto rehash commands
zstyle ":completion:*" rehash true

